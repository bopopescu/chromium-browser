Name: ffmpeg
URL: http://ffmpeg.org/
License: LGPL 2.1
License File: LICENSE
Upstream Git: git://source.ffmpeg.org/ffmpeg.git
Last Upstream Merge: 23bb85b0691d76162da753ce08d8dd03f636ef47, Jul 24 2012

This file documents the layout of the Chromium copy of FFmpeg git, some common
tasks, how to produce the FFmpeg include directory, and how to create the
ffmpeg.gyp file and related configurations.

FFmpeg Git Layout:
==================

Chromium's copy of FFmpeg is a fork of the upstream git repository, see the tags
above for up-to-date cut information.  All of the chromium specific bits, minus
the gyp files, are located under the chromium/ folder off the root.

    ffmpeg.gyp: See the section on ffmpeg.gyp below.

    ffmpeg_generated.gypi: Pregenerated gyp listing of files necessary to build
      every platform.  See chromium/scripts/generate_gyp.py for more details.

    chromium/binaries/win: Prebuilt Windows binaries, necessary as FFmpeg must
      be built manually on Windows at the time of this writing.  See
      http://crbug.com/39887 for more information.

    chromium/scripts: Utilities for building the gyp and config files.

    chromium/config/...: Pregenerated FFmpeg config options for each platform
      and architecture; e.g., ChromeOS: ARM-Neon, Linux: X64, etc.

    chromium/patches/...: Chromium specific changes which haven't yet made it
      upstream.  See chromium/patches/README for more details on each patch.

      Historically, the .patch files were staged on top of a source tarball
      instead of the Git repository we have now.  The .patch files are kept for
      tracking purposes.  The new system only requires that you add an entry to
      the README file with a link to the tracking issue and code review.

Help w/ Common Tasks:
=====================

-- Submitting changes to the Chromium Git.

The goal of the Chromium Git is to eventually just be a mirror of the upstream
Git repository.  Which means every change made should be upstreamed.  If you
make a change, please add an entry to chromium/patches/README with a link to
the tracking issue and code review for your change.

The normal Chromium CL submission process works fine, but if you prefer to use
Gerrit instead of Rietveld, push your code with the following:

  git push ssh://gerrit.chromium.org:29418/chromium/third_party/ffmpeg \
  HEAD:refs/for/master

Note: You'll need a Gerrit account to use this method, see:

  http://www.chromium.org/chromium-os/developer-guide/gerrit-guide

If your change adds new files to the repository, you'll need to regenerate the
GYP defines by following the directions in chromium/scripts/generate_gyp.py.

You'll also need to regenerate the Windows binaries, ping dalecurtis or scherkus
about how to do this.  Sadly it's a manual process at the moment, see
http://crbug.com/39887 for more information.

After all that's done and your change has landed in the Git repository, you'll
need to export it to the Subversion repository.  See the next help entry.

-- Exporting the Git repository to Subversion.

Sadly, as of this writing (Jan 2012) Chromium does not support building from Git
repos.  The builders rely on an export of the Git repo to SVN for builds.  A
DEPS entry controls which revision the builders are currently using.

The steps for doing this are:

  cd <some path outside of ffmpeg Git>
  svn co svn://svn.chromium.org/chrome/trunk/deps/third_party/ffmpeg
  <path to ffmpeg Git>/chromium/scripts/sync_svn.py <Git path> <SVN path>
  cd <svn repo>
  svn commit -m "<Some happy message about updating FFmpeg SVN.>"

You'll also need to update the internal ffmpeg SVN with the Chrome DLLs for
Windows and roll the internal and external DEPS files.

-- Performing an upstream merge.

The upstream merge process follows the normal Git merge process:

  git remote add upstream git://source.ffmpeg.org/ffmpeg.git
  git fetch upstream
  git merge upstream/master

  # If conflicts:
  git mergetool

  <Follow rest of "Submitting changes to the Chromium Git.">

  # Use git push for submission so commit history is kept.  Might require merge
  # approval on your Gerrit account.  Do not commit any other way.
  git push origin master

  <Follow the steps under "Exporting the Git repository to Subversion."

-- Upstreaming a patch.

  <checkout copy of upstream repo>
  git checkout <hash of last Chromium FFmpeg, see tag above> -b my_patch
  git apply <patch. pulled from code review or cherry-picked from this repo>
  git rebase origin/master
  < Follow FFmpeg guide: http://ffmpeg.org/developer.html#Submitting-patches-1 >

Once your change has been upstreamed, please update the chromium/patches/README
file with the status.  The next time an upstream merge is done, the committer
will clear out all the patches which have been upstreamed.

-- Cherry-picking a patch from upstream.

  # Tell our repo about the upstream one.
  git remote add upstream git://source.ffmpeg.org/ffmpeg.git
  git fetch upstream

  # Create a new branch based off of master for committing our patch.
  git checkout master -b my_new_branch

  # Pull the patch out of upstream.
  git cherry-pick <hash of commit in upstream>

  <Follow the steps in "Submitting changes to the Chromium Git." above>

Building:
=========

-- FFmpeg headers in the 'chromium/include' directory.

The include directory contains FFmpeg's public header files from the output of
a "make install" command.  The header files are from Chromium's copy of FFmpeg.

Steps to reproduce:
  1) If on Windows, refer to our MinGW/MSYS environment setup:
       http://src.chromium.org/viewvc/chrome/trunk/deps/third_party/mingw/
  2) Chromium's copy of FFmpeg, should already have it if you're reading this.
  3) Follow the instructions to build and install.
  4) Go to your install location and copy the following into the Chromium tree:
       /path/to/install/include/libavcodec
       /path/to/install/include/libavformat
       /path/to/install/include/libavutil

The project contains some hand-written DEF files used to generate import
libraries to permit dynamically loading FFmpeg.  On Windows, the libraries are
linked in using /DELAYLOAD to avoid having the DLLs present at run-time.  On
POSIX systems, dlopen() is used to achieve a similar effect.

We don't use the import libraries generated from building FFmpeg because they
export every method by ordinal, which makes binary compatibility with different
builds of FFmpeg difficult if not impossible.  Furthermore, it is much easier
to update a DEF file instead of rebuilding FFmpeg to generate new import
libraries.


-- Recreating the ffmpeg.gyp file and populating the config directory.
The ffmpeg.gyp file is meant to be used in place of FFmpeg's

   ./configure && make

steps.  The file was created by inspecting the build log from above.
The FFmpeg build is relatively straightforward.  All files are built with
the same CFLAGS.  The config.h and version.h files are the only files generated
by ./configure that are included elsewhere.  They require a small bit of
post-processing.

Other than the configure step, FFmpeg just compiles its .c files, assembles a
few more using yasm, and that's it.  Exact instructions for reproducing
ffmpeg.gyp are in the "Detailed Directions" section.

Here is a list of gotchas that have shown up.
  1) FFmpeg requires special configure (--disable-optimizations) in order
     to be built with -O0 successfully due to some of the hand-written
     assembler using ebp.  -O0 implies -fno-omit-frame-pointer which breaks
     this. This will produce compiler errors like:
       libavcodec/cabac.h:527: error: can't find a register in class
       'GENERAL_REGS' while reloading 'asm'
       cabac.h:527: error: 'asm' operand has impossible constraints

  2) Sometimes, with -O0, invalid code will be exposed because dead-branch
     pruning is disabled in gcc.  This can manifest itself as strange link
     issues or compile issues.  Be careful to read all warnings in this case.

  3) Since config.h is generated via ./configure, the generated file will
     be sensitive to the configuration of the machine it was produced on.
     In particular, yasm does not seem to always be detected if
     cross-compiling for 32-bit on a 64-bit machine. Since yasm is built in
     tree, make sure to force things with --enable-yasm.

  4) yasm needs to be installed on mac and windows if not already there.

  5) Similar to issue #3, ./configure may detect the presence of SDL and
     adjust config.h accordingly. This is harmless because all the SDL
     related code has been disabled in our configuration.

  6) On Mac ia32, we want to be able to compile WITHOUT -fomit-frame-pointer
     (so breakpad can function).  To do this, we need to disable the use of the
     EBP register, otherwise some of FFmpeg's inline assembly will cause
     compilation errors similar to gotcha #1.  For more details, see the file
     comment in the munge_config_optimizations.sh. This script will fix up
     the generated config.h to be building without -fomit-frame-pointer.

Short Directions:
=================
  1) Create config.h and config.asm as needed.
     On Linux run
       ./chromium/scripts/build_ffmpeg.sh linux ia32 <absolute path to ..>
       ./chromium/scripts/build_ffmpeg.sh linux x64 <absolute path to ..>

     On Linux chroot run
       ./chromium/scripts/build_ffmpeg.sh linux arm <absolute path to ..>
       ./chromium/scripts/build_ffmpeg.sh linux arm-neon <absolute path to ..>

     On Mac run
       ./chromium/scripts/build_ffmpeg.sh mac ia32 <absolute path to ..>

     On Windows run
       ./chromium/scripts/build_ffmpeg.sh win ia32 <absolute path to ..>

  2) Finally, collect all these directories and copy all config files
     into the source tree using

       ./chromium/scripts/copy_config.sh

Detailed Directions:
====================
  1) Run the configure in a directory out of the tree with the arguments you
     want.  To see what was used before, find the config.h for the platform
     of interest in:

       src/third_party/ffmpeg/source/config/[branding]/[platform]/[variant]

     The value of the FFMPEG_CONFIGURATION macro should have the configure
     commandline that generated the file.

     Note that if you are trying to build a 32-bit FFmpeg for linux on a
     64-bit box, the extra flags you want to pass to ./configure are

       --arch=i686 --extra-cflags=-m32 --extra-ldflags=-m32

     Also, as noted in gotcha #4, explicitly setting --enable-yasm is
     a good idea. (These flags have been added to build_ffmpeg.sh.)

  2) Copy the newly generated config.h and version.h into the correct platform
     location:

       src/third_party/ffmpeg/chromium/config/[branding]/[platform]/[variant]

     Make sure to double-check that config.h and version.h are the only files
     of interest.  By that, I mean check that the other generated files are
     makefiles, documentation, .pc files, or something else that is not
     relevant to our build.

     TODO(ajwong): Check if we can modify version.h to tag our builds.

  3) If on ia32, handle gotcha #6 by munging the geneated config.h file to
     disable use of EBP.  Call the munge_config_optimizations.sh script on
     the config.h for each ia32 variant. (This has been implemented in
     build_ffmpeg.sh.)

     ** This script is not idempotent. Don't run it twice **

     Remember, this is only necessary for ia32 config.h files.  Running this
     on config.h files for other platforms (in particular, for x64) will
     likely result in unecessarily slow code, or compile failures.

  4) Next, capture all the output from a build of libavcodec.so and
     libavformat.so.  We will use the build log as a reference for making
     the ffmpeg.gyp file.

       make libavcodec/libavcodec.so libavformat/libavformat.so \
          > ffmpeg_build_log 2> ffmpeg_build_err

     For Mac, replace the ".so" in the files above with ".dylib".

     To get detailed output you might have to comment in common.mak

       #$(foreach VAR,$(BRIEF), \
       #    $(eval override $(VAR) = $($(VAR))))

  5) Check ffmpeg_build_err to see if there are any significant
     anomalies.  FFmpeg source generates a lot of compiler warnings; it
     is safe to ignore those.

  6) Examine all non-gcc commands to see if we're missing anything
     interesting:

       grep -v '^gcc' ffmpeg_build_log

     There should be yasm commands for assembling two yasm files, but nothing
     else.  Include those yasm files in the sources list for gyp.  That means

       grep -v '^gcc\|^yasm'

     should generate nothing beyond "cd" and "ln" commands.

  7) Verify that the all the gcc commands have the same compiler flags.
     Do that with the following "one-liner":

       grep - '^gcc' ffmpeg_build_log |
       grep -v ' -MM ' |
       grep -v ' -shared ' |
       sed -e 's/ -MF .*$//' |
       sort | uniq -c

     This should find all gcc commands, exclude the dependency generation
     lines, the link lines, and strip the output/input file names leaving
     just the compiler flags + invocation.  You should only see one "line"
     of output.  If there is more than one, figure out if the differences
     in compiler flags are significant, and then use your best judgment.

  8) Examine the output from step 6 and update the compiler flags in
     ffmpeg.gyp. For easier cut/paste, append the following to the previous
     command line to isolate each flag on its own line and add
     single-quotes:

       tr -s ' ' | tr ' ' '\n' | sed -e "s/\(.*\)/'\1',/" | sort -u

  9) Next, examine the link flags to see if anything interesting appears.

        grep ' -shared ' ffmpeg_build_log  |
        tr ' ' '\n' |
        grep -Ev '^[^-].*' |
        grep -v rpath |
        grep -Ev '^-L' |
        sort -u

     This should find all link lines, move each flag to its own line,
     remove any argument that isn't a flag, remove all the rpaths (not
     useful for us anyways), and remove all the -L lines (also not useful
     for us).

     The most interesting will likely be the -Wl,.* lines. Update the
     ldflags section in ffmpeg.gyp accordingly.

 10) Lastly, Find all the build .c files and update the sources line (this is
     very similar to step 7):

       grep -E '^gcc' ffmpeg_build_log |
       grep -v ' -MM ' |
       grep -v ' -shared ' |
       sed -e "s|.* -o .* \(.*\)$|'source/patched-ffmpeg/\1',|" |
       sort

 11) Attempt to build. :)

*12) Update the the sources! clause to exclude files that should only be built
     for Chromium.  For this, you basically need to do the steps above once
     with the configure options for Chrome, then once with the options for
     Chromium and diff the list of .c and .asm source files.
