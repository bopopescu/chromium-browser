# -*- python -*-
# Copyright (c) 2012 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

from SCons.Errors import UserError

Import('env')

#
#
# Build on x86 only.
#
#
if not env.Bit('target_x86'):
  Return()

# Defines the source directory where validator generated files should be added.
rl_src_dir = '$OBJ_ROOT/src/trusted/validator_ragel'
val_src_dir = '$MAIN_DIR/src/trusted/validator_ragel/gen'
# Currently we only provide ragel pre-built for Linux.
ragel_binary = '$MAIN_DIR/../third_party/ragel/ragel.linux'

# Source generation:
#
#   dfagen : Regenerate any autogenerated source files.

generate = False
if 'dfagen' in COMMAND_LINE_TARGETS or 'dfaclean' in COMMAND_LINE_TARGETS:
  generate = True

if generate:
  if not env.Bit('host_linux'):
    raise UserError('Right now DFA generation is only supported on Linux')

  # Set of generated (source) decoder automatas.
  automatas = []

  # Source generation step 1: Build generator of ragel files.
  #
  # We have generator which reads .def files and produced automata definition.
  #
  # Ragel is included in most Linux distributions, but it's not standard tool
  # on MacOS/Windows thus we only support gneration of automata under Linux.
  # This also means that we don't need to make sure gen_dfa.cc is portable to
  # non-POSIX platforms (in particular it's not Windows compatible).

  env_gen_dfa = env.Clone()
  env_gen_dfa.Append(CCFLAGS=['-std=c++0x', '-DNACL_TRUSTED_BUT_NOT_TCB'])

  gen_dfa = env_gen_dfa.ComponentProgram(
      'gen_dfa',
      ['unreviewed/gen_dfa.cc'])

  # Source generation step 2: Generate decoder automatas.
  #
  # Now we are back to conditionally defining the large automatas generated
  # by gen_dfa.

  # Generate 32 and 64 bit versions of decoders and validators.
  for bits in ['32', '64']:
    for automata in ['decoder', 'validator']:
      # We are cheating here: there are two autogenerated files:
      #  .rl and _consts.c, but we only track .rl one.  This is safe because
      #  _consts.c file includes constants referenced by .rl file and if .rl
      #  file is not changed _consts.c is guaranteed to be the same (reverse
      #  is not true).
      rl_file = '%s_x86_%s_instruction.rl' % (automata, bits)
      const_file = '%s/%s_x86_%s_instruction_consts.c' % (
          val_src_dir, automata, bits)
      exe_path = '${STAGING_DIR}/${PROGPREFIX}gen_dfa${PROGSUFFIX}'
      env.Command(
          target=rl_file,
          source=[
            exe_path,
            'unreviewed/general_purpose_instructions.def',
            'unreviewed/system_instructions.def',
            'unreviewed/x87_instructions.def',
            'unreviewed/mmx_instructions.def',
            'unreviewed/xmm_instructions.def',
            'unreviewed/nops.def'],
          action=[('${SOURCES[0]} -o ${TARGET} -c %s -m %s -d %s ${SOURCES[1]} '
            '${SOURCES[2]} ${SOURCES[3]} ${SOURCES[4]} ${SOURCES[5]} '
            '${SOURCES[6]}') % (
            # Const file (-c): not tracked by SCONS (see above)
            const_file,
            # Argument for CPU type (-m): either "ia32" or "amd64".
            {'32': 'ia32', '64': 'amd64'}[bits],
            # Argument for actions selection (-d): selects only actions we need.
            {'decoder32':
              'check_access,opcode,parse_operands_states,mark_data_fields',
             'decoder64':
              'check_access,opcode,parse_operands_states,mark_data_fields',
             'validator32':
              ('check_access,opcode,parse_operands,parse_operands_states,'
               'instruction_name,mark_data_fields,nacl-forbidden,'
               'imm_operand_action,rel_operand_action'),
             'validator64':
              ('opcode,instruction_name,mark_data_fields,imm_operand_action,'
               'rel_operand_action,nacl-forbidden,parse_nonwrite_registers,'
               'parse_x87_operands,parse_mmx_operands,parse_xmm_operands,'
               'parse_ymm_operands,parse_relative_operands,'
               'parse_immediate_operands,parse_operands_states,'
               'parse_operand_positions')
            }[automata+bits])]
      )
      automatas.append(rl_file)
      c_file = '%s_x86_%s.c' % (automata, bits)
      c_full_filename = '%s/%s' % (val_src_dir, c_file)
      if automata == 'decoder':
        ragel_flags = '-T0'
      elif bits == '32':
        ragel_flags = '-G2'
      else:
        ragel_flags = '-GT2'
      env.Command(
          target=c_file,
          source=['unreviewed/%s_x86_%s.rl' % (automata, bits), rl_file],
          action=['%s %s -LL -I%s ${SOURCES[0]} -o ${TARGET}' % (
              ragel_binary, ragel_flags, rl_src_dir)]
      )
      automatas.append(c_file)
      def Inject_GeneratedFile_Header(target, source, env):
        source_filename = str(source[0])
        target_filename = str(target[0])
        with open(source_filename, 'r') as source_file:
          with open(target_filename, 'w') as target_file:
            target_file.write("""/* native_client/%s
 * THIS FILE IS AUTO-GENERATED. DO NOT EDIT.
 * Compiled for %s mode.
 */""" % (target_filename,
      {'x86_32': 'ia32', 'x86_64': 'x86-64'}[target_filename[-8:-2]]))
            target_file.write(source_file.read().split('*/', 1)[1])
      env.Command(
          target=c_full_filename,
          source=['%s/%s' % (rl_src_dir, c_file)],
          action=Inject_GeneratedFile_Header
      )
      automatas.append(c_full_filename)

  # Generate 32 and 64 bit versions of decoders and validators
  env.AlwaysBuild(env.Alias('dfagen', automatas))
  env.AlwaysBuild(env.Alias('dfaclean', action=[Delete(x) for x in automatas]))

# Generate 32 and 64 bit versions of decoders and validators.  Both libraries
# are used for command-line decoder and validator those detect specific
# architecture of the ELF file provided.
env.ComponentLibrary('dfa_validate_x86_32',
                     ['gen/validator_x86_32.c'])
env.ComponentLibrary('dfa_validate_x86_64',
                     ['gen/validator_x86_64.c'])
env.ComponentLibrary('dfa_decode_x86_32',
                     ['gen/decoder_x86_32.c'])
env.ComponentLibrary('dfa_decode_x86_64',
                     ['gen/decoder_x86_64.c'])

# Glue library called from service runtime. The source file depends on the
# target architecture.
caller_lib_bits = None
if env.Bit('target_x86_32'):
  caller_lib_bits = '32'
if env.Bit('target_x86_64'):
  caller_lib_bits = '64'
if caller_lib_bits:
  caller_lib = 'dfa_validate_caller_x86_%s' % caller_lib_bits
  env.ComponentLibrary(caller_lib,
                       ['unreviewed/dfa_validate_%s.c' % caller_lib_bits])

# Command-line decoder.
env.ComponentProgram(
    'decoder_test',
    ['unreviewed/decoder_test.c'],
    EXTRA_LIBS=['dfa_decode_x86_32', 'dfa_decode_x86_64'])

# Command-line validator.
validator_test_exe = env.ComponentProgram(
    'validator_test',
    ['unreviewed/validator_test.c'],
    EXTRA_LIBS=['dfa_validate_x86_32', 'dfa_validate_x86_64'])

# Python-based regression test. TODO(pasko): remove it when validator_tests are
# migrated to be able to run with the new validator.
if env.Bit('validator_ragel'):
  test_node = env.CommandTest('validator_test_py.out',
                              command=['${PYTHON}',
                                       env.File('unreviewed/validator_test.py'),
                                       validator_test_exe])
  env.AddNodeToTestSuite(test_node, ['small_tests'], 'run_validator_test_py')
