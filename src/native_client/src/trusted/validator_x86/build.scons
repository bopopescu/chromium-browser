# -*- python -*-
# Copyright (c) 2011 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.


import os
import sys
Import('env')

#
#
# Build x86 only pieces
#
#
if not env.Bit('target_x86'): Return()

# ------------------------------------------------------
# General adjustments to the environment for builds.

# Make a copy of debug CRT for now.
# TODO(bradnelson): there should be a better way to generalize this requirement.
# NOTE: debug builds on windows break without this
crt = []
if env.AllBits('windows', 'debug'):
  for i in ['.', '$STAGING_DIR']:
    crt += env.Replicate(i, '$VC80_DIR/vc/redist/Debug_NonRedist/'
                         'x86/Microsoft.VC80.DebugCRT')
    crt += env.Replicate(i, '$VC80_DIR/vc/redist/x86/Microsoft.VC80.CRT')

# Defines which test sets tests should be added to.
STANDARD_TESTS = ['small_tests', 'validator_tests']

# Define which test sets modeling test should be added to
MODELING_TESTS = STANDARD_TESTS + ['validator_modeling']

# TODO(bradchen): eliminate need for the following line
env.FilterOut(CCFLAGS=['-Wextra', '-Wswitch-enum', '-Wsign-compare'])

#
#
# force_cpp_o
#
# This object file is used to mark a library/executable as containing C++.
force_cpp_o = env.ComponentObject('force_cpp.cc')

# Defines the source directory where validator generated files should be added.
val_src_dir = '$MAIN_DIR/src/trusted/validator_x86'

# Create environment for command-line tools and testing, rather than
# part of the TCB. Then define compile-time flag that communicates
# that we are compiling in the test environment (rather than for the TCB).
test_env = env.Clone();
test_env.Append(CCFLAGS=['-DNACL_TRUSTED_BUT_NOT_TCB'])

# ======================================================================
# Helper functions for getting automated tests from the corresponding
# test directory.

TESTDATA_DIR = 'testdata/'
TESTDATA_SUBARCH_DIR = TESTDATA_DIR + env['TARGET_SUBARCH'] + '/'

# Generates the set of test files with the given extension.
def __GoldenFiles(ext):
  return Glob(TESTDATA_SUBARCH_DIR + '*.' + ext)

# Generates base names (i.e. minus path and extention (ext) suffix) of
# all test data input files.
def __FilterOutTestFileBaseGen(files, ext):
  for f in files:
    yield os.path.basename(f.path).replace('.' + ext, '')

# Generates the set of golden bases for the given extension.
def __GoldenBases(ext):
  return __FilterOutTestFileBaseGen(__GoldenFiles(ext), ext)

# Generates the corresponding test file from the given base.
def __BaseTestFile(base, ext):
  return test_env.File(TESTDATA_SUBARCH_DIR + base + '.' + ext)

# Generates the corresponding test name from the given base.
def __BaseTestName(test, base, ext):
  return test + '_' + base + '_' + ext

# Generates the corresponding output file from the given base.
def __OutTestFile(test, base, ext):
  return test + '_' + base + '.' + ext + '.out'

def __AddTest(test, test_env, base, ext, command, groups):
  test_env.AddNodeToTestSuite(command, groups, __BaseTestName(test, base, ext))


# The following are common library components that use elements
# of both x86-32 and x86-64 validators.
test_env.ComponentLibrary(test_env.NaClTargetArchSuffix('ncdis_util'),
                          ['ncdis_segments.c',
                           'nc_read_segment.c',
                           test_env.NaClTargetArchSuffix('ncenuminsts') + '.c'])

# The following are copycode routines for x86-32 and x86-64.
# TODO(karl): Break this up so that we don't need to load
# non-shared code in library.
env.ComponentLibrary(env.NaClTargetArchSuffix('nccopy'), [
    'nccopycode.c',
    'nccopycode_stores.S',
    ])

# ======================================================================
# Decoder unittests
if test_env.Bit('target_x86_32'):
  # TODO(kschimpf): remove this when the validator builds as 64-bits.
  if test_env.Bit('build_x86_32'):
    ncdecode_tests = test_env.ComponentProgram(
        'ncdecode_tests',
        ['ncdecode_tests.c'],
        EXTRA_LIBS=[test_env.NaClTargetArchSuffix('ncdis_seg_sfi_verbose'),
                    ])

    node = test_env.CommandTest(
        'ncdecode_tests.out',
        [ncdecode_tests],
        )

    test_env.AddNodeToTestSuite(node, STANDARD_TESTS)

# ======================================================================
# Build command line decoder.
#
ncdis = test_env.ComponentProgram(
  'ncdis', [
    'ncdis.c',
    force_cpp_o,
  ],
  EXTRA_LIBS=[test_env.NaClTargetArchSuffix('ncdis_util'),
              test_env.NaClTargetArchSuffix('ncfileutils'),
              test_env.NaClTargetArchSuffix('ncdis_decode_tables'),
              test_env.NaClTargetArchSuffix('nc_opcode_modeling_verbose'),
              'utils',
              ])

env.Requires(ncdis, crt)

# ======================================================================
# Valiator unittests
if test_env.Bit('target_x86_32'):
  ncval_tests = test_env.ComponentProgram(
      'ncval_tests',
      ['ncval_tests.c'],
      EXTRA_LIBS=[test_env.NaClTargetArchSuffix('ncdis_util'),
                  test_env.NaClTargetArchSuffix('ncval_seg_sfi'),
                  ])
  test_env.Requires(ncval_tests, crt)

  node = test_env.CommandTest(
      'ncval_tests.out',
      [ncval_tests],
      )

  test_env.AddNodeToTestSuite(node, STANDARD_TESTS, 'run_ncval_tests')

# ======================================================================
# Define what decoder was historically being used for tests. This allows
# existing tests to continue to follow that historical assumption.

if test_env.Bit('target_x86_32'):
  _ncdis_historical_decoder = '--validator_decoder'
else:
  _ncdis_historical_decoder = '--full_decoder'


# ======================================================================
# Decoder vs objdump tests
# TODO: add tests using the toolchain binaries in the sdk
if test_env.Bit('linux') and test_env.Bit('target_x86_32'):
  test = 'discmp'
  ext = 'nexe'
  for base in __GoldenBases(ext):
    node = test_env.CommandTest(
        __OutTestFile(test, base, ext),
        ["${PYTHON}", test_env.File('discmp.py'), test_env.File('ncdis'),
         __BaseTestFile(base, ext)],
        )
    __AddTest(test, test_env, base, ext, node, ['large_tests'])

# ======================================================================
# Run tests on ncdis, where the input is self documenting (i.e. the input
# file matches the generated resulit.
def __AddNcdisSelfDocTests(validator_decoder, internals_also):
  test = 'ncdis_test'
  options = ['--commands=-']
  input_ext = 'input'
  if internals_also:
    output_ext = 'internal'
    options.append('--internal')
  else:
    output_ext = input_ext
    options.append('--self_document')
  if validator_decoder:
    output_ext = 'v' + output_ext
    options.append('--validator_decoder')
  else:
    options.append('--full_decoder')
  for base in __GoldenBases(output_ext):
    command = [ncdis] + options
    ncdis_test = test_env.CommandTest(
        __OutTestFile(test, base, output_ext),
        command,
        stdin = __BaseTestFile(base, input_ext),
        stdout_golden = __BaseTestFile(base, output_ext))
    __AddTest(test, test_env, base, output_ext, ncdis_test,
              STANDARD_TESTS)

for validator_decoder in [False, True]:
  for internals_also in [False, True]:
    __AddNcdisSelfDocTests(validator_decoder, internals_also)

# ======================================================================
# Build command line validator.
ncval = test_env.ComponentProgram(
  'ncval', [
    'ncval.c',
    force_cpp_o,
  ],
  EXTRA_LIBS=[test_env.NaClTargetArchSuffix('ncdis_util'),
              test_env.NaClTargetArchSuffix('ncval_seg_sfi'),
              test_env.NaClTargetArchSuffix('ncfileutils'),
              test_env.NaClTargetArchSuffix('ncdis_decode_tables'),
              'utils',
              ])

test_env.SDKInstallBin('ncval', ncval)

test_env.Requires(ncval, crt)

# ======================================================================
# Validator tests against real nacl images
# TODO: add death tests
# TODO: add tests using binaries produced by nacl.scons files
# TODO: consider comparing the actual output (not just exit codes)
# Validate tests
if env.Bit('target_x86_32'):
  test = 'validate'
  ext = 'nexe'
  for base in __GoldenBases(ext):
    node = test_env.CommandTest(
        __OutTestFile(test, base, ext),
        [ncval, '-t', __BaseTestFile(base, ext)],
        )
    __AddTest(test, test_env, base, ext, node, ['large_tests'])

# Run tests using ncdis on test files.
def __AddNcDisTests(validator_decoder):
  test = 'ncdis_hex'
  options = ['--hex_text=-']
  if validator_decoder:
    ext = 'vdis'
    options.append('--validator_decoder')
  else:
    ext = 'dis'
    options.append('--full_decoder')
  for base in __GoldenBases(ext):
    node_dis = test_env.CommandTest(
        __OutTestFile(test, base, ext),
        [ncdis] + options,
        stdin = __BaseTestFile(base, 'hex'),
        stdout_golden = __BaseTestFile(base, ext))
    __AddTest(test, test_env, base, ext, node_dis, STANDARD_TESTS)

for validator_decoder in [False, True]:
  __AddNcDisTests(validator_decoder)

# Run tests using ncval on test files. Assume that write sandbox
# tests use extension 'val' while read/write sandbox tests use extension
# 'rval'. Assumes that a suffix of 0 on the extension implies no CPUID flags
# set. Otherwise, assume that test is run with all CPUID flags set.
def __AddNcvalSfiTests(test_readwrite, test_cpuid_all, detailed,
                       test_annotate, validator_decoder):
  if env.Bit('target_x86_64'):
    test = 'ncval64_hex'
    options = ['--hex_text=-', '--max_errors=-1']
    if test_readwrite:
      ext = 'rval'
      options.append('--readwrite_sfi')
    else:
      ext = 'val'
      options.append('--write_sfi')
    if (detailed):
      ext += 'd'
      options.append('--detailed')
    else:
      options.append('--detailed=false')
    if test_cpuid_all:
      options.append('--cpuid-all')
    else:
      ext = ext + '0'
      options.append('--cpuid-none')
    if test_annotate:
      ext += 'a'
      options.append('--annotate');
    else:
      options.append('--annotate=false');
    if validator_decoder:
      ext = "vd-" + ext
      options.append('--validator_decoder')
    for base in __GoldenBases(ext):
      command = [ncval] + options
      node_val = test_env.CommandTest(
          __OutTestFile(test, base, ext),
          command,
          stdin = __BaseTestFile(base, 'hex'),
          stdout_golden = __BaseTestFile(base, ext))
      __AddTest(test, test_env, base, ext, node_val,
                STANDARD_TESTS + ['validator_tests'])

for read_write in [False, True]:
  for cpu_features_all in [False, True]:
    for detailed in [False, True]:
      for annotate in [False, True]:
        for validator_decoder in [False, True]:
          __AddNcvalSfiTests(read_write, cpu_features_all, detailed,
                             annotate, validator_decoder)

# Run segment sandboxing tests of pre/post conditions for the validator.
def __AddNcvalTestingTests(report_errors):
  options = ['--hex_text=-', '--cpuid-all',
             '--readwrite_sfi', '--annotate=false']
  ext = 'cval'
  if report_errors:
    # Show error messages that would otherwise hide pre/post conditions
    # in the corresponding cval test case. Used to verify that we only
    # report pre/post conditions for instructions that are NaCl legal
    # except for pre/post conditions.
    ext = ext + "e"
    options.append('--max_errors=-1')
    options.append('--print_all_conds')
  test = 'ncval_conds'
  for base in __GoldenBases(ext):
    command = [ncval] + options
    node_val = test_env.CommandTest(
        __OutTestFile(test, base, ext),
        command,
        stdin = __BaseTestFile(base, 'hex'),
        stdout_golden = __BaseTestFile(base, ext))
    __AddTest(test, test_env, base, ext, node_val, ['ncval_testing'])

if test_env.Bit('ncval_testing') and test_env.Bit('target_x86_64'):
  for report_errors in [False, True]:
    __AddNcvalTestingTests(report_errors)

# Run segment sandboxing tests using ncval on test files.
def __AddNcvalSegmentTests(test_cpuid_all, test_stats, detailed):
  if env.Bit('target_x86_32'):
    options = ['--hex_text=-',
               '--max_errors=-1']
    ext = 'nval'
    if (detailed):
      ext += 'd'
      options.append('--detailed')
    else:
      options.append('--detailed=false')
    if (test_stats):
      ext += 's'
      options.append('--stats')
    if test_cpuid_all:
      options.append('--cpuid-all')
    else:
      ext += '0'
      options.append('--cpuid-none')
    test = 'ncval32_hex'
    for base in __GoldenBases(ext):
      command = [ncval] + options
      node_val = test_env.CommandTest(
          __OutTestFile(test, base, ext),
          command,
          stdin = __BaseTestFile(base, 'hex'),
          stdout_golden = __BaseTestFile(base, ext))
      __AddTest(test, test_env, base, ext, node_val,
                STANDARD_TESTS)

for cpu_features_all in [False, True]:
  for test_stats in [False, True]:
    for detailed in [False, True]:
      __AddNcvalSegmentTests(cpu_features_all, test_stats, detailed)

# Run tests for stubout on test files. The input file uses extension hex.
def __AddNcValStuboutTests():
  test = 'ncval_stubout'
  options = ['--hex_text=-', '--stubout']
  ext = 'sval'
  for base in __GoldenBases(ext):
    command = [ncval] + options
    node_stubout = test_env.CommandTest(
        __OutTestFile(test, base, ext),
        command,
        stdin = __BaseTestFile(base, 'hex'),
        stdout_golden = __BaseTestFile(base, ext))
    __AddTest(test, test_env, base, ext, node_stubout,
              STANDARD_TESTS)

__AddNcValStuboutTests()

# Run test to show that --max_errors=-1 works in 32 bit mode.
def __AddNegMaxErrors():
  if env.Bit('target_x86_32'):
    test = 'neg_max_errs'
    base = 'ret'
    ext = 'nval'
    node_val = test_env.CommandTest(
        __OutTestFile(test, base, ext),
        [ncval, '--max_errors=-1', '--hex_text=-'],
        stdin = __BaseTestFile(base, 'hex'),
        stdout_golden = __BaseTestFile(base, ext))
    __AddTest(test, test_env, base, ext, node_val,
              STANDARD_TESTS)

__AddNegMaxErrors()

if test_env.Bit('target_x86_64'):
  node = test_env.CommandTest('ncval_hello_x32.out',
                              [ncval,
                               env.File(os.path.join('${MAIN_DIR}/src/trusted',
                                                     'service_runtime',
                                                     'testdata/x86_64',
                                                     'hello_x32.nexe'))])
  env.AddNodeToTestSuite(node, STANDARD_TESTS, 'run_ncval_hello_x32_test')
