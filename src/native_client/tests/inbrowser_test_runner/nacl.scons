# -*- python -*-
# Copyright (c) 2012 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import json
import posixpath

Import('env')

env.ComponentLibrary('testrunner', ['test_runner.c'])
env.ComponentLibrary('testrunner_browser', ['test_runner_ppapi.c'])

dest_copy = env.Replicate('$STAGING_DIR', 'test_runner.html')
env.Replicate('$STAGING_DIR',
              '${SCONSTRUCT_DIR}/tools/browser_tester/browserdata/nacltest.js')

exe_list = [
    'imc_shm_mmap_test',
    'random_test',
    ]

# These conditionals mirror conditionals in
# dynamic_code_loading/nacl.scons.  The dyncode tests don't work with
# dynamic linking yet, and they don't build with non-ARM PNaCl.
if (env.Bit('nacl_static_link') and
    not (env.Bit('bitcode') and not env.Bit('target_arm'))):
  exe_list.append('dynamic_load_test')

  # Dynamic code modification is not implemented for ARM yet.
  if not env.Bit('target_arm'):
    exe_list.append('dynamic_modify_test')


def AddTest(env, test_name, exe_list, parallel=False):
  test_files = [env.File('${STAGING_DIR}/%s${PROGSUFFIX}'
                         % env.ProgramNameForNmf(exe_name))
                for exe_name in exe_list]

  def WriteManifestList(target, source, env):
    nmf_names = ['%s.nmf' % exe_name for exe_name in exe_list]
    data = ('// This file is automatically generated\n'
            'var G_NMF_TEST_LIST = %s;\n' % json.dumps(nmf_names))
    fh = open(target[0].abspath, 'w')
    fh.write(data)
    fh.close()

  nmf_list_js = env.Command(['%s_nmf_test_list.js' % test_name], [],
                            WriteManifestList)[0]
  # Scons does not track the dependency of nmf_list_js on exe_list, so
  # we must always recreate nmf_list_js when it is used.
  env.AlwaysBuild(nmf_list_js)

  node = env.PPAPIBrowserTester(
      '%s.out' % test_name, url='test_runner.html',
      nmf_names=exe_list,
      files=[env.File('test_runner.html')] + test_files,
      map_files=[('nmf_test_list.js', nmf_list_js)],
      test_args=[('parallel', int(parallel))],
      osenv=['NACL_EXE_STDOUT=DEBUG_ONLY:dev://postmessage',
             'NACL_EXE_STDERR=DEBUG_ONLY:dev://postmessage'])

  # Disabled on Valgrind because of multiple nexes.
  # TODO(eugenis): enable when Valgrind learns to autodetect the nexe name
  env.AddNodeToTestSuite(node, ['chrome_browser_tests'], test_name,
                         disable_irt_suffix=True,
                         is_broken=env.PPAPIBrowserTesterIsBroken() or
                                   env.Bit('running_on_valgrind'))

if not env.Bit('tests_use_irt'):
  Return()

AddTest(env, 'run_inbrowser_test_runner', exe_list, parallel=False)
AddTest(env, 'run_inbrowser_test_runner_parallel', exe_list, parallel=True)

# "exception_test" is added as a separate test so that it can be
# separately enabled or disabled from the Chromium side.
# TODO(mseaborn): When this test works fully in Chromium on all OSes,
# merge this back into run_inbrowser_test_runner.
# See http://code.google.com/p/nativeclient/issues/detail?id=2602
exception_env = env.Clone()
exception_env['ENV']['NACL_UNTRUSTED_EXCEPTION_HANDLING'] = '1'
AddTest(exception_env, 'run_inbrowser_exception_test', ['exception_test'])
