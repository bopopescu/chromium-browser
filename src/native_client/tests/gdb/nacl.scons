# -*- python -*-
# Copyright (c) 2012 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

Import('env')

if 'TRUSTED_ENV' not in env:
  Return()

# PNaCl and ARM bots don't have GDB.
# TODO(halyavin) : check debugger with PNaCl and enable test if possible.
if (env.Bit('host_mac') or
    (env.Bit('host_windows') and env.Bit('build_x86_32')) or
    env.Bit('bitcode') or env.Bit('target_arm')):
  Return()

# We need -O0 to make stepping predictable and read local variables/function
# arguments that may otherwise be optimized out.
env.Append(CCFLAGS=['-O0', '-g'])

sel_ldr = env.GetSelLdr()
irt = env.GetIrtNexe()

env_vars = [
    'OUT_DIR=%s' % env.subst('${TARGET_ROOT}/test_results'),
    'NACL_SEL_LDR=%s' % sel_ldr,
    'NACL_IRT=%s' % irt,
    'NACL_GDB=%s' % env['GDB'],
    ]
if env.Bit('asan'):
  env_vars += ['NACL_ASAN=1']
if not env.Bit('nacl_static_link'):
  env_vars += ['NACL_LD_SO=%s' % env.subst('${NACL_SDK_LIB}/runnable-ld.so'),
               'NACL_LIBS=%s' % env['NACL_SDK_LIB']]

gdb_test_guest = env.ComponentProgram(
    'gdb_test_guest', 'gdb_test_guest.c',
    EXTRA_LIBS=['${NONIRT_LIBS}'])

node = env.CommandTest(
    'gdb_stepi_after_break.out',
    command=['${PYTHON}', env.File('stepi_after_break.py')],
    osenv=env_vars + ['GDB_TEST_GUEST=%s' % gdb_test_guest.abspath],
    extra_deps=[sel_ldr, irt, gdb_test_guest])

env.AddNodeToTestSuite(node, ['large_tests'],
                       'run_gdb_stepi_after_break_test')

node = env.CommandTest(
    'gdb_print_symbol.out',
    command=['${PYTHON}', env.File('print_symbol.py')],
    osenv=env_vars + ['GDB_TEST_GUEST=%s' % gdb_test_guest.abspath],
    extra_deps=[sel_ldr, irt, gdb_test_guest])

# TODO(eaeltsin): fix x86_64-nacl-gdb and enable this test.
# The test fails on printing wrong value of function parameter, see
# http://code.google.com/p/nativeclient/issues/detail?id=2898
env.AddNodeToTestSuite(node, ['large_tests'], 'run_gdb_print_symbol_test',
                       is_broken=env.Bit('build_x86_64'))

node = env.CommandTest(
    'gdb_break_inside_function.out',
    command=['${PYTHON}', env.File('break_inside_function.py')],
    osenv=env_vars + ['GDB_TEST_GUEST=%s' % gdb_test_guest.abspath],
    extra_deps=[sel_ldr, irt, gdb_test_guest])

env.AddNodeToTestSuite(node, ['large_tests'],
                       'run_gdb_break_inside_function_test')

node = env.CommandTest(
    'gdb_stack_trace.out',
    command=['${PYTHON}', env.File('stack_trace.py')],
    osenv=env_vars + ['GDB_TEST_GUEST=%s' % gdb_test_guest.abspath],
    extra_deps=[sel_ldr, irt, gdb_test_guest])

env.AddNodeToTestSuite(node, ['large_tests'], 'run_gdb_stack_trace_test',
                       is_broken=env.Bit('build_x86_64'))

# GDB treats multithreaded programs specially. Provide distinct nexe for
# multithreaded tests to isolate multiple threads-specific issues.
gdb_test_guest_thread = env.ComponentProgram(
    'gdb_test_guest_thread', 'gdb_test_guest_thread.c',
    EXTRA_LIBS=['${PTHREAD_LIBS}', '${NONIRT_LIBS}'])

node = env.CommandTest(
    'gdb_break_continue_thread.out',
    command=['${PYTHON}', env.File('break_continue_thread.py')],
    osenv=env_vars + ['GDB_TEST_GUEST=%s' % gdb_test_guest_thread.abspath],
    extra_deps=[sel_ldr, irt, gdb_test_guest_thread])

env.AddNodeToTestSuite(node, ['large_tests'],
                       'run_gdb_break_continue_thread_test')

node = env.CommandTest(
    'gdb_syscall_thread.out',
    command=['${PYTHON}', env.File('syscall_thread.py')],
    osenv=env_vars + ['GDB_TEST_GUEST=%s' % gdb_test_guest_thread.abspath],
    extra_deps=[sel_ldr, irt, gdb_test_guest_thread])

env.AddNodeToTestSuite(node, ['large_tests'],
                       'run_gdb_syscall_thread_test')
