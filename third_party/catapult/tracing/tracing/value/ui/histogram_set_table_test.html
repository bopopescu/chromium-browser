<!DOCTYPE html>
<!--
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/assert_utils.html">
<link rel="import" href="/tracing/base/utils.html">
<link rel="import" href="/tracing/ui/base/deep_utils.html">
<link rel="import" href="/tracing/value/ui/histogram_set_view.html">

<script>
'use strict';
tr.b.unittest.testSuite(function() {
  // TODO(benjhayden): use table-cell and name-cell APIs, don't pierce them.

  const TEST_BOUNDARIES = tr.v.HistogramBinBoundaries.createLinear(0, 1e3, 20);

  async function buildTable(test, histograms) {
    // This should mirror HistogramImporter in order to be as similar to
    // results.html as possible.
    const table = document.createElement('tr-v-ui-histogram-set-table');

    table.viewState = new tr.v.ui.HistogramSetViewState();
    await table.viewState.update({
      displayStatisticName: 'avg',
      groupings: [tr.v.HistogramSet.GROUPINGS.HISTOGRAM_NAME],
    });

    table.style.display = 'none';
    test.addHTMLOutput(table);

    table.addEventListener('display-ready', () => {
      table.style.display = '';
    });

    const collector = new tr.v.HistogramParameterCollector();
    collector.process(histograms);

    await table.build(
        histograms,
        histograms.sourceHistograms,
        collector.labels,
        async message => {
          await tr.b.animationFrame();
        });
    return table;
  }

  function range(start, end) {
    const result = [];
    for (let i = start; i < end; ++i) result.push(i);
    return result;
  }

  function newHistogram(name, opt_options) {
    const options = opt_options || {};
    const hist = new tr.v.Histogram(name,
        options.unit || tr.b.Unit.byName.count_smallerIsBetter,
        options.boundaries || TEST_BOUNDARIES);

    if (options.description) hist.description = options.description;
    if (options.shortName) hist.shortName = options.shortName;

    for (const sample of (options.samples || [])) {
      if (sample instanceof Array) {
        hist.addSample(sample[0], sample[1]);
      } else {
        hist.addSample(sample);
      }
    }

    if (options.telemetry) {
      new tr.v.d.TelemetryInfo(options.telemetry).addToHistogram(hist);
    }
    return hist;
  }

  function getBaseTable(table) {
    return tr.b.findDeepElementMatchingPredicate(table, e =>
        e.tagName === 'TR-UI-B-TABLE');
  }

  function getNameCells(table) {
    return tr.b.findDeepElementsMatchingPredicate(table, e =>
        e.tagName === 'TR-V-UI-HISTOGRAM-SET-TABLE-NAME-CELL');
  }

  function getTableCells(table) {
    return tr.b.findDeepElementsMatchingPredicate(table, e =>
        e.tagName === 'TR-V-UI-HISTOGRAM-SET-TABLE-CELL');
  }

  test('viewSearchQuery', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('a', {samples: [1]}),
      newHistogram('b', {samples: [2]}),
    ]);
    const table = await buildTable(this, histograms);

    await table.viewState.update({searchQuery: 'a'});
    let cells = getTableCells(table);
    assert.lengthOf(cells, 1);

    await table.viewState.update({searchQuery: '[z-'});
    cells = getTableCells(table);
    assert.lengthOf(cells, 2);

    await table.viewState.update({searchQuery: 'x'});
    cells = getTableCells(table);
    assert.lengthOf(cells, 0);

    await table.viewState.update({searchQuery: ''});
    cells = getTableCells(table);
    assert.lengthOf(cells, 2);
  });

  test('controlSearchQuery', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('a', {samples: [1]}),
      newHistogram('b'),
    ]);
    histograms.getHistogramNamed('a').diagnostics.set(
        'r', new tr.v.d.RelatedHistogramSet([
          histograms.getHistogramNamed('b')]));
    const table = await buildTable(this, histograms);
    await table.viewState.tableRowStates.get('a').cells.get('Value').update(
      {isOpen: true});
    const link = tr.b.findDeepElementMatchingPredicate(
        table, e => e.tagName === 'TR-UI-A-ANALYSIS-LINK');
    link.click();
    assert.strictEqual('^(b)$', table.viewState.searchQuery);
  });

  test('viewReferenceDisplayLabel', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('a', {samples: [1], telemetry: {label: 'A'}}),
      newHistogram('a', {samples: [2], telemetry: {label: 'B'}}),
    ]);
    const table = await buildTable(this, histograms);
    const baseTable = getBaseTable(table);
    assert.isUndefined(baseTable.selectedTableColumnIndex);
    // TODO assert cell.referenceHistogram

    await table.viewState.update({referenceDisplayLabel: 'A'});
    assert.strictEqual(1, baseTable.selectedTableColumnIndex);
    // TODO assert cell.referenceHistogram

    await table.viewState.update({referenceDisplayLabel: 'B'});
    assert.strictEqual(2, baseTable.selectedTableColumnIndex);
    // TODO assert delta statistics
    // TODO assert cell.referenceHistogram
  });

  test('viewDisplayStatisticName', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('a', {samples: range(0, 10), telemetry: {label: 'A'}}),
      newHistogram('a', {samples: range(10, 20), telemetry: {label: 'B'}}),
    ]);
    const table = await buildTable(this, histograms);
    let scalarSpans = tr.b.findDeepElementsMatchingPredicate(table, e =>
        e.tagName === 'TR-V-UI-SCALAR-SPAN');
    assert.lengthOf(scalarSpans, 2);
    assert.strictEqual('5', scalarSpans[0].unit.format(scalarSpans[0].value));
    assert.strictEqual('15', scalarSpans[1].unit.format(scalarSpans[1].value));

    await table.viewState.update({displayStatisticName: 'std'});
    scalarSpans = tr.b.findDeepElementsMatchingPredicate(table, e =>
        e.tagName === 'TR-V-UI-SCALAR-SPAN');
    assert.lengthOf(scalarSpans, 2);
    assert.strictEqual('3', scalarSpans[0].unit.format(scalarSpans[0].value));
    assert.strictEqual('3', scalarSpans[1].unit.format(scalarSpans[1].value));
  });

  test('viewShowAll', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('a', {samples: [1]}),
      newHistogram('b'),
    ]);
    histograms.getHistogramNamed('a').diagnostics.set(
        'r', new tr.v.d.RelatedHistogramSet([
          histograms.getHistogramNamed('b')]));
    const table = await buildTable(this, histograms);

    let cells = getNameCells(table);
    assert.lengthOf(cells, 1);
    assert.strictEqual('a', cells[0].row.name);

    await table.viewState.update({showAll: true});
    cells = getNameCells(table);
    assert.lengthOf(cells, 2);
    assert.strictEqual('a', cells[0].row.name);
    assert.strictEqual('b', cells[1].row.name);
  });

  test('viewSortColumnIndex', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('a', {samples: [1]}),
      newHistogram('b', {samples: [2]}),
    ]);
    const table = await buildTable(this, histograms);

    // TODO assert sorting

    await table.viewState.update({sortColumnIndex: 0});
    // TODO assert sorting

    await table.viewState.update({sortColumnIndex: 1});
    // TODO assert sorting
  });

  test('controlSortColumnIndex', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('a', {samples: [1]}),
      newHistogram('b', {samples: [2]}),
    ]);
    const table = await buildTable(this, histograms);

    assert.strictEqual(0, table.viewState.sortColumnIndex);

    tr.b.findDeepElementsMatchingPredicate(
        table, e => e.tagName === 'TR-UI-B-TABLE-HEADER-CELL')[0].click();
    assert.strictEqual(0, table.viewState.sortColumnIndex);

    tr.b.findDeepElementsMatchingPredicate(
        table, e => e.tagName === 'TR-UI-B-TABLE-HEADER-CELL')[1].click();
    assert.strictEqual(1, table.viewState.sortColumnIndex);
  });

  test('viewSortDescending', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('a', {samples: [1]}),
      newHistogram('b', {samples: [2]}),
    ]);
    const table = await buildTable(this, histograms);

    await table.viewState.update({sortColumnIndex: 0});
    // TODO assert sorting

    await table.viewState.update({sortDescending: true});
    // TODO assert sorting

    await table.viewState.update({sortDescending: false});
    // TODO assert sorting
  });

  test('controlSortDescending', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('a', {samples: [1]}),
      newHistogram('b', {samples: [2]}),
    ]);
    const table = await buildTable(this, histograms);
    await table.viewState.update({sortColumnIndex: 0});

    assert.isFalse(table.viewState.sortDescending);

    tr.b.findDeepElementsMatchingPredicate(
        table, e => e.tagName === 'TR-UI-B-TABLE-HEADER-CELL')[0].click();
    assert.isTrue(table.viewState.sortDescending);

    tr.b.findDeepElementsMatchingPredicate(
        table, e => e.tagName === 'TR-UI-B-TABLE-HEADER-CELL')[0].click();
    assert.isFalse(table.viewState.sortDescending);
  });

  test('viewConstrainNameColumn', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('a'.repeat(100)),
    ]);
    const table = await buildTable(this, histograms);
    const nameCell = tr.b.getOnlyElement(getNameCells(table));
    assert.isTrue(nameCell.isOverflowing);
    assert.isAbove(350, nameCell.getBoundingClientRect().width);
    assert.isTrue(table.viewState.constrainNameColumn);
    const dots = tr.b.findDeepElementMatchingPredicate(
        table, e => e.textContent === tr.v.ui.MIDLINE_HORIZONTAL_ELLIPSIS);
    assert.strictEqual('block', dots.style.display);

    await table.viewState.update({constrainNameColumn: false});
    assert.isFalse(nameCell.isOverflowing);
    assert.isBelow(350, nameCell.getBoundingClientRect().width);

    await table.viewState.update({constrainNameColumn: true});
    assert.isTrue(nameCell.isOverflowing);
    assert.isAbove(350, nameCell.getBoundingClientRect().width);
  });

  test('controlConstrainNameColumn', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('a'.repeat(100)),
    ]);
    const table = await buildTable(this, histograms);
    const nameCell = tr.b.getOnlyElement(getNameCells(table));
    assert.isTrue(nameCell.isOverflowing);
    assert.isAbove(350, nameCell.getBoundingClientRect().width);
    assert.isTrue(table.viewState.constrainNameColumn);
    const dots = tr.b.findDeepElementMatchingPredicate(
        table, e => e.textContent === tr.v.ui.MIDLINE_HORIZONTAL_ELLIPSIS);
    assert.strictEqual('block', dots.style.display);

    tr.b.findDeepElementMatchingPredicate(table, e =>
        e.textContent === tr.v.ui.MIDLINE_HORIZONTAL_ELLIPSIS).click();
    assert.isFalse(table.viewState.constrainNameColumn);
    await tr.b.animationFrame();
    assert.isFalse(nameCell.isOverflowing);
    assert.isBelow(350, nameCell.getBoundingClientRect().width);

    tr.b.findDeepElementMatchingPredicate(table, e =>
        e.textContent === tr.v.ui.MIDLINE_HORIZONTAL_ELLIPSIS).click();
    assert.isTrue(table.viewState.constrainNameColumn);
    await tr.b.animationFrame();
    assert.isTrue(nameCell.isOverflowing);
    assert.isAbove(350, nameCell.getBoundingClientRect().width);
  });

  test('viewRowExpanded', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('a', {samples: [1], telemetry: {storyDisplayName: 'A'}}),
      newHistogram('a', {samples: [2], telemetry: {storyDisplayName: 'B'}}),
    ]);
    const table = await buildTable(this, histograms);
    await table.viewState.update({groupings: [
      tr.v.HistogramSet.GROUPINGS.HISTOGRAM_NAME,
      tr.v.HistogramSet.GROUPINGS.STORY_NAME,
    ]});
    assert.lengthOf(getTableCells(table), 1);

    await table.viewState.tableRowStates.get('a').update({isExpanded: true});
    assert.lengthOf(getTableCells(table), 3);

    await table.viewState.tableRowStates.get('a').update({isExpanded: false});
    assert.lengthOf(getTableCells(table), 1);
  });

  test('controlRowExpanded', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('a', {samples: [1], telemetry: {storyDisplayName: 'A'}}),
      newHistogram('a', {samples: [2], telemetry: {storyDisplayName: 'B'}}),
    ]);
    const table = await buildTable(this, histograms);
    await table.viewState.update({groupings: [
      tr.v.HistogramSet.GROUPINGS.HISTOGRAM_NAME,
      tr.v.HistogramSet.GROUPINGS.STORY_NAME,
    ]});
    assert.isFalse(table.viewState.tableRowStates.get('a').isExpanded);

    const nameCell = tr.b.getOnlyElement(getNameCells(table));
    nameCell.click();
    assert.isTrue(table.viewState.tableRowStates.get('a').isExpanded);

    nameCell.click();
    assert.isFalse(table.viewState.tableRowStates.get('a').isExpanded);
  });

  test('viewIsOverviewed', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('a', {samples: [1], telemetry: {
        storyDisplayName: 'A', label: 'A'}}),
      newHistogram('a', {samples: [2], telemetry: {
        storyDisplayName: 'B', label: 'A'}}),
      newHistogram('a', {samples: [1], telemetry: {
        storyDisplayName: 'A', label: 'B'}}),
      newHistogram('a', {samples: [2], telemetry: {
        storyDisplayName: 'B', label: 'B'}}),
    ]);
    const table = await buildTable(this, histograms);
    await table.viewState.update({groupings: [
      tr.v.HistogramSet.GROUPINGS.HISTOGRAM_NAME,
      tr.v.HistogramSet.GROUPINGS.STORY_NAME,
    ]});

    const nameCells = getNameCells(table);
    const cells = getTableCells(table);
    assert.isFalse(nameCells[0].isOverviewed);

    await table.viewState.tableRowStates.get('a').update({isOverviewed: true});
    assert.isTrue(nameCells[0].isOverviewed);

    await table.viewState.tableRowStates.get('a').update({isOverviewed: false});
    assert.isFalse(nameCells[0].isOverviewed);
  });

  test('controlIsOverviewed', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('a', {samples: [1], telemetry: {
        storyDisplayName: 'A', label: 'A'}}),
      newHistogram('a', {samples: [2], telemetry: {
        storyDisplayName: 'B', label: 'A'}}),
      newHistogram('a', {samples: [1], telemetry: {
        storyDisplayName: 'A', label: 'B'}}),
      newHistogram('a', {samples: [2], telemetry: {
        storyDisplayName: 'B', label: 'B'}}),
    ]);
    const table = await buildTable(this, histograms);
    await table.viewState.update({groupings: [
      tr.v.HistogramSet.GROUPINGS.HISTOGRAM_NAME,
      tr.v.HistogramSet.GROUPINGS.STORY_NAME,
    ]});

    assert.isFalse(table.viewState.tableRowStates.get('a').isOverviewed);

    const nameCells = getNameCells(table);
    tr.b.findDeepElementMatchingPredicate(nameCells[0], e =>
        e.id === 'show_overview').click();
    assert.isTrue(table.viewState.tableRowStates.get('a').isOverviewed);

    tr.b.findDeepElementMatchingPredicate(nameCells[0], e =>
        e.id === 'hide_overview').click();
    assert.isFalse(table.viewState.tableRowStates.get('a').isOverviewed);
  });

  // TODO(benjhayden): Move this to a unit test for table-cell.
  test('viewCellOpen', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('a', {samples: [1]}),
    ]);
    const table = await buildTable(this, histograms);
    const cell = tr.b.getOnlyElement(getTableCells(table));
    assert.isFalse(cell.isHistogramOpen);

    await table.viewState.tableRowStates.get('a').cells.get('Value').update(
        {isOpen: true});
    assert.isTrue(cell.isHistogramOpen);

    await table.viewState.tableRowStates.get('a').cells.get('Value').update(
        {isOpen: false});
    assert.isFalse(cell.isHistogramOpen);
  });

  // TODO(benjhayden): Move this to a unit test for table-cell.
  test('controlCellOpen', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('a', {samples: [1], telemetry: {label: 'A'}}),
      newHistogram('a', {samples: [1], telemetry: {label: 'B'}}),
    ]);
    const table = await buildTable(this, histograms);

    assert.isFalse(table.viewState.tableRowStates.get('a').cells.get('A')
        .isOpen);
    const cells = getTableCells(table);

    tr.b.findDeepElementMatchingPredicate(cells[0], e =>
        e.tagName === 'TR-V-UI-SCALAR-SPAN').click();
    assert.isTrue(table.viewState.tableRowStates.get('a').cells.get('A')
        .isOpen);

    tr.b.findDeepElementMatchingPredicate(cells[0], e =>
        e.id === 'close_histogram').click();
    assert.isFalse(table.viewState.tableRowStates.get('a').cells.get('A')
        .isOpen);

    tr.b.findDeepElementMatchingPredicate(table, e =>
        e.id === 'open_histograms').click();
    assert.isTrue(table.viewState.tableRowStates.get('a').cells.get('A')
        .isOpen);
    assert.isTrue(table.viewState.tableRowStates.get('a').cells.get('B')
        .isOpen);

    tr.b.findDeepElementMatchingPredicate(table, e =>
        e.id === 'close_histograms').click();
    assert.isFalse(table.viewState.tableRowStates.get('a').cells.get('A')
        .isOpen);
    assert.isFalse(table.viewState.tableRowStates.get('a').cells.get('B')
        .isOpen);
  });

  // TODO(benjhayden): Move this to histogram_span_test.
  test('viewBrushedBinRange', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('a', {samples: range(0, 1000)}),
    ]);
    const table = await buildTable(this, histograms);
    await table.viewState.tableRowStates.get('a').cells.get('Value').update(
      {isOpen: true});
    const histSpan = tr.b.findDeepElementMatchingPredicate(table, e =>
        e.tagName === 'TR-V-UI-HISTOGRAM-SPAN');
    assert.isTrue(histSpan.brushedBinRange.isEmpty);

    await table.viewState.tableRowStates.get('a').cells.get('Value').update(
        {brushedBinRange: tr.b.math.Range.fromExplicitRange(5, 10)});
    assert.strictEqual(5, histSpan.brushedBinRange.min);
    assert.strictEqual(10, histSpan.brushedBinRange.max);
  });

  // TODO(benjhayden): Move this to histogram_span_test.
  test('controlBrushedBinRange', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('a', {samples: range(0, 1000)}),
    ]);
    const table = await buildTable(this, histograms);
    tr.b.assertRangeEquals(new tr.b.math.Range(),
        table.viewState.tableRowStates.get('a').cells.get('Value')
            .brushedBinRange);

    // TODO brush bins
    // TODO assert brushedBinRange
  });

  // TODO(benjhayden): Move this to a unit test for table-cell.
  test('viewMergeSampleDiagnostics', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('a', {samples: range(0, 5).map(i =>
        [i, {bd: tr.v.d.Breakdown.fromDict({values: {
          a: 5 - i, b: i + 5, c: i}})}])}),
    ]);
    const table = await buildTable(this, histograms);
    await table.viewState.tableRowStates.get('a').cells.get('Value').update(
      {isOpen: true});
    await table.viewState.tableRowStates.get('a').cells.get('Value').update(
        {brushedBinRange: tr.b.math.Range.fromExplicitRange(0, 10)});
    const histSpan = tr.b.findDeepElementMatchingPredicate(table, e =>
        e.tagName === 'TR-V-UI-HISTOGRAM-SPAN');
    assert.isTrue(histSpan.mergeSampleDiagnostics);

    await table.viewState.tableRowStates.get('a').cells.get('Value').update(
        {mergeSampleDiagnostics: false});
    assert.isFalse(histSpan.mergeSampleDiagnostics);

    await table.viewState.tableRowStates.get('a').cells.get('Value').update(
        {mergeSampleDiagnostics: true});
    assert.isTrue(histSpan.mergeSampleDiagnostics);
  });

  // TODO(benjhayden): Move this to a unit test for table-cell.
  test('controlMergeSampleDiagnostics', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('a', {samples: range(0, 5).map(i =>
        [i, {bd: tr.v.d.Breakdown.fromDict({values: {
          a: 5 - i, b: i + 5, c: i}})}])}),
    ]);
    const table = await buildTable(this, histograms);
    await table.viewState.tableRowStates.get('a').cells.get('Value').update(
      {isOpen: true});
    await table.viewState.tableRowStates.get('a').cells.get('Value').update(
        {brushedBinRange: tr.b.math.Range.fromExplicitRange(0, 10)});
    assert.isTrue(table.viewState.tableRowStates.get('a').cells.get(
        'Value').mergeSampleDiagnostics);
    const merge = tr.b.findDeepElementMatchingPredicate(table, e =>
        e.id === 'merge_sample_diagnostics');

    merge.click();
    assert.isFalse(table.viewState.tableRowStates.get('a').cells.get(
        'Value').mergeSampleDiagnostics);

    merge.click();
    assert.isTrue(table.viewState.tableRowStates.get('a').cells.get(
        'Value').mergeSampleDiagnostics);
  });

  test('rebin', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('foo', {
        samples: range(0, 100),
        telemetry: {label: 'A'},
        boundaries: tr.v.HistogramBinBoundaries.SINGULAR}),
      newHistogram('foo', {
        samples: range(50, 150),
        telemetry: {label: 'B'},
        boundaries: tr.v.HistogramBinBoundaries.SINGULAR}),
    ]);
    const table = await buildTable(this, histograms);

    const cells = getTableCells(table);
    assert.lengthOf(cells, 2);
    assert.lengthOf(cells[0].histogram.allBins,
        2 + tr.v.DEFAULT_REBINNED_COUNT);
    assert.lengthOf(cells[1].histogram.allBins,
        2 + tr.v.DEFAULT_REBINNED_COUNT);
    assert.strictEqual(cells[0].histogram.allBins[0].range.max, 0);
    assert.strictEqual(cells[1].histogram.allBins[0].range.max, 0);
    assert.strictEqual(cells[0].histogram.allBins[41].range.min, 200);
    assert.strictEqual(cells[1].histogram.allBins[41].range.min, 200);
  });

  test('nameCellOverflow', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('a'.repeat(100)),
    ]);
    const table = await buildTable(this, histograms);
    const nameCell = tr.b.getOnlyElement(getNameCells(table));
    assert.isTrue(nameCell.isOverflowing);
    assert.isAbove(350, nameCell.getBoundingClientRect().width);

    const dots = tr.b.findDeepElementMatchingPredicate(
        table, e => e.textContent === tr.v.ui.MIDLINE_HORIZONTAL_ELLIPSIS);
    assert.strictEqual('block', dots.style.display);
    dots.click();

    await tr.b.animationFrame();
    assert.isFalse(nameCell.isOverflowing);
    assert.isBelow(350, nameCell.getBoundingClientRect().width);
  });

  test('nameCellOverflowOnExpand', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('a', {telemetry: {storyDisplayName: '0'.repeat(100)}}),
      newHistogram('a', {telemetry: {storyDisplayName: '1'.repeat(100)}}),
    ]);
    const table = await buildTable(this, histograms);
    await table.viewState.update({groupings: [
      tr.v.HistogramSet.GROUPINGS.HISTOGRAM_NAME,
      tr.v.HistogramSet.GROUPINGS.STORY_NAME,
    ]});

    const dots = tr.b.findDeepElementMatchingPredicate(
        table, e => e.textContent === tr.v.ui.MIDLINE_HORIZONTAL_ELLIPSIS);
    assert.strictEqual('none', dots.style.display);

    const baseTable = getBaseTable(table);
    await table.viewState.tableRowStates.get('a').update({isExpanded: true});

    const nameCell = tr.b.findDeepElementMatchingPredicate(table, e =>
        e.tagName === 'TR-V-UI-HISTOGRAM-SET-TABLE-NAME-CELL' &&
        e.row.name === '0'.repeat(100));
    await tr.b.animationFrame();
    assert.isTrue(nameCell.isOverflowing);
    assert.isAbove(350, nameCell.getBoundingClientRect().width);

    assert.strictEqual('block', dots.style.display);
    dots.click();

    await tr.b.animationFrame();
    assert.isFalse(nameCell.isOverflowing);
    assert.isBelow(350, nameCell.getBoundingClientRect().width);
  });

  test('overviewCharts', async function() {
    const boundaries = tr.v.HistogramBinBoundaries.createLinear(0, 150, 10);
    const histograms = new tr.v.HistogramSet([
      newHistogram('foo', {boundaries, samples: [0], telemetry: {
        storyDisplayName: 'story0', label: '0'}}),
      newHistogram('foo', {boundaries, samples: [10], telemetry: {
        storyDisplayName: 'story0', label: '1'}}),

      newHistogram('foo', {boundaries, samples: [100], telemetry: {
        storyDisplayName: 'story1', label: '0'}}),
      newHistogram('foo', {boundaries, samples: [110], telemetry: {
        storyDisplayName: 'story1', label: '1'}}),

      newHistogram('bar', {boundaries, samples: [0], telemetry: {
        storyDisplayName: 'story0', label: '0'}}),
      newHistogram('bar', {boundaries, samples: [9], telemetry: {
        storyDisplayName: 'story0', label: '1'}}),

      newHistogram('bar', {boundaries, samples: [90], telemetry: {
        storyDisplayName: 'story1', label: '0'}}),
      newHistogram('bar', {boundaries, samples: [99], telemetry: {
        storyDisplayName: 'story1', label: '1'}}),
    ]);
    const now = new Date().getTime();
    const table = await buildTable(this, histograms);
    await table.viewState.update({groupings: [
      tr.v.HistogramSet.GROUPINGS.HISTOGRAM_NAME,
      tr.v.HistogramSet.GROUPINGS.STORY_NAME,
    ]});

    for (const row of tr.v.ui.HistogramSetTableRowState.walkAll(
        table.viewState.tableRowStates.values())) {
      await row.update({isOverviewed: true});
    }

    let charts = tr.b.findDeepElementsMatchingPredicate(
        table, e => ((e.id === 'overview_container') &&
                     (e.style.display !== 'none')));
    charts = charts.map(div => div.children[0]);
    assert.lengthOf(charts, 6);

    assert.deepEqual(JSON.stringify(charts[0].data),
        JSON.stringify([{x: '0', y: 45}, {x: '1', y: 54}]));
    tr.b.assertRangeEquals(
        charts[0].dataRange, tr.b.math.Range.fromExplicitRange(0, 99));

    assert.deepEqual(
        charts[1].data, [{x: 'story0', y: 0}, {x: 'story1', y: 90}]);
    tr.b.assertRangeEquals(
        charts[1].dataRange, tr.b.math.Range.fromExplicitRange(0, 99));

    assert.deepEqual(
        charts[2].data, [{x: 'story0', y: 9}, {x: 'story1', y: 99}]);
    tr.b.assertRangeEquals(
        charts[2].dataRange, tr.b.math.Range.fromExplicitRange(0, 99));

    assert.deepEqual(charts[3].data, [{x: '0', y: 50}, {x: '1', y: 60}]);
    tr.b.assertRangeEquals(
        charts[3].dataRange, tr.b.math.Range.fromExplicitRange(0, 110));

    assert.deepEqual(
        charts[4].data, [{x: 'story0', y: 0}, {x: 'story1', y: 100}]);
    tr.b.assertRangeEquals(
        charts[4].dataRange, tr.b.math.Range.fromExplicitRange(0, 110));

    assert.deepEqual(
        charts[5].data, [{x: 'story0', y: 10}, {x: 'story1', y: 110}]);
    tr.b.assertRangeEquals(
        charts[5].dataRange, tr.b.math.Range.fromExplicitRange(0, 110));

    for (const row of tr.v.ui.HistogramSetTableRowState.walkAll(
        table.viewState.tableRowStates.values())) {
      await row.update({isOverviewed: false});
    }

    charts = tr.b.findDeepElementsMatchingPredicate(
        table, e => ((e.id === 'overview_container') &&
                     (e.style.display !== 'none')));
    assert.lengthOf(charts, 0);
  });

  test('mergeRelationships', async function() {
    const benchmarkStartMs = new Date().getTime();
    const boundaries = tr.v.HistogramBinBoundaries.createLinear(0, 150, 10);
    const histograms = new tr.v.HistogramSet();

    for (let i = 0; i < 2; ++i) {
      for (let j = 0; j < 2; ++j) {
        const telemetry = new tr.v.d.TelemetryInfo({
          storyDisplayName: 'story' + i,
          benchmarkName: 'bench' + j,
          benchmarkStartMs,
          label: 'Value',
        });

        const sample = (i * 100) + (j * 10);

        const sourceHist = new tr.v.Histogram(
            'source', tr.b.Unit.byName.count, boundaries);
        sourceHist.addSample(sample);
        telemetry.addToHistogram(sourceHist);
        histograms.addHistogram(sourceHist);

        const aHist = new tr.v.Histogram(
            'a', tr.b.Unit.byName.count, boundaries);
        aHist.addSample(sample / 10);
        telemetry.addToHistogram(aHist);
        histograms.addHistogram(aHist);

        const bHist = new tr.v.Histogram(
            'b', tr.b.Unit.byName.count, boundaries);
        bHist.addSample(sample * 9 / 10);
        telemetry.addToHistogram(bHist);
        histograms.addHistogram(bHist);

        const breakdown = new tr.v.d.RelatedHistogramBreakdown();
        breakdown.add(aHist);
        breakdown.add(bHist);
        sourceHist.diagnostics.set('breakdown', breakdown);
      }
    }

    const table = await buildTable(this, histograms);
    // TODO test
    // TODO move to histogram_set_table_row_test.html
  });

  test('regression3281', async function() {
    // https://github.com/catapult-project/catapult/issues/3281
    const histograms = new tr.v.HistogramSet();

    const telemetryA = new tr.v.d.TelemetryInfo({label: 'A'});
    const telemetryB = new tr.v.d.TelemetryInfo({label: 'B'});

    tr.b.Settings.set(tr.v.ui.REFERENCE_DISPLAY_LABEL_KEY, telemetryA.label);
    tr.b.Settings.set(tr.v.ui.DISPLAY_STATISTIC_KEY, 'z-score');

    const hist0a = new tr.v.Histogram('foo',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, TEST_BOUNDARIES);
    for (let i = 0; i < 100; ++i) {
      hist0a.addSample(Math.random() * 1e3);
    }
    histograms.addHistogram(hist0a);
    telemetryA.addToHistogram(hist0a);

    const hist1a = new tr.v.Histogram('bar',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, TEST_BOUNDARIES);
    for (let i = 0; i < 100; ++i) {
      hist1a.addSample(Math.random() * 1e3);
    }
    histograms.addHistogram(hist1a);
    telemetryA.addToHistogram(hist1a);

    const hist0b = new tr.v.Histogram('foo',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, TEST_BOUNDARIES);
    for (let i = 0; i < 100; ++i) {
      hist0b.addSample(Math.random() * 1e3);
    }
    histograms.addHistogram(hist0b);
    telemetryB.addToHistogram(hist0b);

    const hist1b = new tr.v.Histogram('bar',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, TEST_BOUNDARIES);
    for (let i = 0; i < 100; ++i) {
      hist1b.addSample(Math.random() * 1e3);
    }
    histograms.addHistogram(hist1b);
    telemetryB.addToHistogram(hist1b);

    const table = await buildTable(this, histograms);
    // TODO test
  });

  test('sortByDisplayStatistic', async function() {
    const histograms = new tr.v.HistogramSet();
    const now = new Date().getTime();

    const barHist = new tr.v.Histogram('bar',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, TEST_BOUNDARIES);
    barHist.addSample(0);
    barHist.addSample(10);

    const fooHist = new tr.v.Histogram('foo',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, TEST_BOUNDARIES);
    fooHist.addSample(5);

    histograms.addHistogram(fooHist);
    histograms.addHistogram(barHist);

    const table = await buildTable(this, histograms);

    await table.viewState.update({
      sortColumnIndex: 1,
      sortDescending: false,
      displayStatisticName: 'min',
    });

    let nameCells = getNameCells(table);
    assert.strictEqual(nameCells[0].row.name, 'bar');
    assert.strictEqual(nameCells[1].row.name, 'foo');

    await table.viewState.update({sortDescending: true});

    nameCells = getNameCells(table);
    assert.strictEqual(nameCells[0].row.name, 'foo');
    assert.strictEqual(nameCells[1].row.name, 'bar');

    await table.viewState.update({displayStatisticName: 'max'});

    nameCells = getNameCells(table);
    assert.strictEqual(nameCells[0].row.name, 'bar');
    assert.strictEqual(nameCells[1].row.name, 'foo');

    await table.viewState.update({sortDescending: false});

    nameCells = getNameCells(table);
    assert.strictEqual(nameCells[0].row.name, 'foo');
    assert.strictEqual(nameCells[1].row.name, 'bar');
  });

  test('displayStatistic', async function() {
    const histograms = new tr.v.HistogramSet();
    const now = new Date().getTime();

    const barHist = new tr.v.Histogram('a',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, TEST_BOUNDARIES);
    barHist.addSample(1);
    barHist.addSample(2);
    barHist.addSample(3);
    new tr.v.d.TelemetryInfo({
      label: 'bar',
      benchmarkStartMs: now,
    }).addToHistogram(barHist);

    const fooHist = new tr.v.Histogram('a',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, TEST_BOUNDARIES);
    fooHist.addSample(10);
    fooHist.addSample(20);
    fooHist.addSample(30);
    new tr.v.d.TelemetryInfo({
      label: 'foo',
      benchmarkStartMs: now,
    }).addToHistogram(fooHist);

    // Add a Histogram with another name so that the table displays the scalars.
    const quxHist = new tr.v.Histogram('qux',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, TEST_BOUNDARIES);
    new tr.v.d.TelemetryInfo({
      label: 'foo',
      benchmarkStartMs: now,
    }).addToHistogram(quxHist);

    histograms.addHistogram(fooHist);
    histograms.addHistogram(barHist);
    histograms.addHistogram(quxHist);

    const table = await buildTable(this, histograms);

    function histogramsEqual(a, b) {
      // This is not an exhaustive equality check. This only tests the fields
      // that are distinguishing for this test().
      if (a.name !== b.name) return false;
      const aTelemetry = tr.v.d.TelemetryInfo.getFromHistogram(a);
      const bTelemetry = tr.v.d.TelemetryInfo.getFromHistogram(b);
      if (!aTelemetry || !bTelemetry) return false;
      // In this test(), |a| is always a merged Histogram and |b| is never a
      // merged Histogram.
      return tr.b.getOnlyElement(aTelemetry.labels) === bTelemetry.label;
    }

    let fooCell = tr.b.findDeepElementMatchingPredicate(table, elem => (
      (elem.tagName === 'TR-V-UI-HISTOGRAM-SET-TABLE-CELL') &&
      elem.histogram &&
      histogramsEqual(elem.histogram, fooHist)));
    assert.isDefined(fooCell);

    let fooContent = tr.b.findDeepElementMatchingPredicate(
        fooCell, elem => elem.id === 'content');
    assert.isDefined(fooContent);

    let barCell = tr.b.findDeepElementMatchingPredicate(table, elem => (
      (elem.tagName === 'TR-V-UI-HISTOGRAM-SET-TABLE-CELL') &&
      elem.histogram &&
      histogramsEqual(elem.histogram, barHist)));
    assert.isDefined(barCell);

    let barContent = tr.b.findDeepElementMatchingPredicate(
        barCell, elem => elem.id === 'content');
    assert.isDefined(barContent);

    assert.strictEqual(table.viewState.displayStatisticName, 'avg');
    assert.strictEqual('20.000 ms', fooContent.textContent);
    assert.strictEqual('2.000 ms', barContent.textContent);

    await table.viewState.update({referenceDisplayLabel: 'foo'});

    fooCell = tr.b.findDeepElementMatchingPredicate(table, elem => (
      (elem.tagName === 'TR-V-UI-HISTOGRAM-SET-TABLE-CELL') &&
      elem.histogram &&
      histogramsEqual(elem.histogram, fooHist)));
    assert.isDefined(fooCell);

    fooContent = tr.b.findDeepElementMatchingPredicate(
        fooCell, elem => elem.id === 'content');
    assert.isDefined(fooContent);

    barCell = tr.b.findDeepElementMatchingPredicate(table, elem => (
      (elem.tagName === 'TR-V-UI-HISTOGRAM-SET-TABLE-CELL') &&
      elem.histogram &&
      histogramsEqual(elem.histogram, barHist)));
    assert.isDefined(barCell);

    barContent = tr.b.findDeepElementMatchingPredicate(
        barCell, elem => elem.id === 'content');
    assert.isDefined(barContent);

    // TODO(benjhayden): Test that histogram-set-controls automatically prepend
    // DELTA when a reference columns is selected.
    await table.viewState.update({displayStatisticName: `${tr.v.DELTA}avg`});
    assert.strictEqual('20.000 ms', fooContent.textContent);
    assert.strictEqual('-18.000 ms', barContent.textContent);

    await table.viewState.update({displayStatisticName: `%${tr.v.DELTA}avg`});

    fooCell = tr.b.findDeepElementMatchingPredicate(table, elem => (
      (elem.tagName === 'TR-V-UI-HISTOGRAM-SET-TABLE-CELL') &&
      elem.histogram &&
      histogramsEqual(elem.histogram, fooHist)));
    assert.isDefined(fooCell);

    fooContent = tr.b.findDeepElementMatchingPredicate(
        fooCell, elem => elem.id === 'content');
    assert.isDefined(fooContent);

    barCell = tr.b.findDeepElementMatchingPredicate(table, elem => (
      (elem.tagName === 'TR-V-UI-HISTOGRAM-SET-TABLE-CELL') &&
      elem.histogram &&
      histogramsEqual(elem.histogram, barHist)));
    assert.isDefined(barCell);

    barContent = tr.b.findDeepElementMatchingPredicate(
        barCell, elem => elem.id === 'content');
    assert.isDefined(barContent);

    assert.strictEqual(table.viewState.displayStatisticName,
        `%${tr.v.DELTA}avg`);
    assert.strictEqual('20.000 ms', fooContent.textContent);
    assert.strictEqual('-90.000%', barContent.textContent);
  });

  test('requestSelectionChange', async function() {
    const histograms = new tr.v.HistogramSet();

    const barHist = new tr.v.Histogram('bar',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, TEST_BOUNDARIES);
    barHist.addSample(1);

    const fooHist = new tr.v.Histogram('foo',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, TEST_BOUNDARIES);
    fooHist.addSample(1);
    const breakdown = new tr.v.d.RelatedHistogramBreakdown();
    breakdown.set('bar', barHist);

    const quxHist = new tr.v.Histogram('qux',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, TEST_BOUNDARIES);
    histograms.addHistogram(quxHist);
    breakdown.set('qux', quxHist);

    fooHist.diagnostics.set('breakdown', breakdown);
    histograms.addHistogram(fooHist);
    histograms.addHistogram(barHist);

    const table = await buildTable(this, histograms);

    let fooCell = tr.b.findDeepElementMatchingPredicate(
        table, elem => (
          (elem.tagName === 'TR-V-UI-HISTOGRAM-SET-TABLE-CELL') &&
          (elem.histogram.name === 'foo')));
    assert.isDefined(fooCell);

    let barCell = tr.b.findDeepElementMatchingPredicate(
        table, elem => (
          (elem.tagName === 'TR-V-UI-HISTOGRAM-SET-TABLE-CELL') &&
          (elem.histogram.name === 'bar')));
    assert.isUndefined(barCell);

    fooCell.isHistogramOpen = true;

    const barLink = tr.b.findDeepElementMatchingPredicate(
        table, elem => elem.tagName === 'TR-UI-A-ANALYSIS-LINK');
    assert.isDefined(barLink);
    barLink.click();

    await tr.b.animationFrame();
    barCell = tr.b.findDeepElementMatchingPredicate(
        table, elem => (
          (elem.tagName === 'TR-V-UI-HISTOGRAM-SET-TABLE-CELL') &&
          (elem.histogram.name === 'bar')));
    assert.isDefined(barCell);

    await table.viewState.update({searchQuery: ''});

    fooCell = tr.b.findDeepElementMatchingPredicate(
        table, elem => (
          (elem.tagName === 'TR-V-UI-HISTOGRAM-SET-TABLE-CELL') &&
          (elem.histogram.name === 'foo')));
    assert.isDefined(fooCell);

    fooCell.isHistogramOpen = true;

    const selectAllLink = tr.b.findDeepElementMatchingPredicate(
        table, elem => (
          (elem.tagName === 'TR-UI-A-ANALYSIS-LINK') &&
          (elem.textContent === 'Select All')));
    assert.isDefined(selectAllLink);
    selectAllLink.click();

    assert.strictEqual(table.viewState.searchQuery, '^(bar|qux)$');

    await tr.b.animationFrame();
    fooCell = tr.b.findDeepElementMatchingPredicate(
        table, elem => (
          (elem.tagName === 'TR-V-UI-HISTOGRAM-SET-TABLE-CELL') &&
          (elem.histogram.name === 'foo')));
    assert.isUndefined(fooCell);

    barCell = tr.b.findDeepElementMatchingPredicate(
        table, elem => (
          (elem.tagName === 'TR-V-UI-HISTOGRAM-SET-TABLE-CELL') &&
          (elem.histogram.name === 'bar')));
    assert.isDefined(barCell);

    const quxCell = tr.b.findDeepElementMatchingPredicate(
        table, elem => (
          (elem.tagName === 'TR-V-UI-HISTOGRAM-SET-TABLE-CELL') &&
          (elem.histogram.name === 'qux')));
    assert.isDefined(quxCell);
  });

  test('search', async function() {
    const histograms = new tr.v.HistogramSet();

    const barHist = new tr.v.Histogram('bar',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, TEST_BOUNDARIES);
    barHist.addSample(1);

    const fooHist = new tr.v.Histogram('foo',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, TEST_BOUNDARIES);
    fooHist.addSample(1);

    histograms.addHistogram(fooHist);
    histograms.addHistogram(barHist);

    const table = await buildTable(this, histograms);

    let fooCell = tr.b.findDeepElementMatchingPredicate(
        table, elem => (
          (elem.tagName === 'TR-V-UI-HISTOGRAM-SET-TABLE-CELL') &&
          (elem.histogram.name === 'foo')));
    assert.isDefined(fooCell);

    let barCell = tr.b.findDeepElementMatchingPredicate(
        table, elem => (
          (elem.tagName === 'TR-V-UI-HISTOGRAM-SET-TABLE-CELL') &&
          (elem.histogram.name === 'bar')));
    assert.isDefined(barCell);

    await table.viewState.update({searchQuery: 'bar'});

    fooCell = tr.b.findDeepElementMatchingPredicate(
        table, elem => (
          (elem.tagName === 'TR-V-UI-HISTOGRAM-SET-TABLE-CELL') &&
          (elem.histogram.name === 'foo')));
    assert.isUndefined(fooCell);

    barCell = tr.b.findDeepElementMatchingPredicate(
        table, elem => (
          (elem.tagName === 'TR-V-UI-HISTOGRAM-SET-TABLE-CELL') &&
          (elem.histogram.name === 'bar')));
    assert.isDefined(barCell);

    await table.viewState.update({searchQuery: 'foo'});

    fooCell = tr.b.findDeepElementMatchingPredicate(
        table, elem => (
          (elem.tagName === 'TR-V-UI-HISTOGRAM-SET-TABLE-CELL') &&
          (elem.histogram.name === 'foo')));
    assert.isDefined(fooCell);

    barCell = tr.b.findDeepElementMatchingPredicate(
        table, elem => (
          (elem.tagName === 'TR-V-UI-HISTOGRAM-SET-TABLE-CELL') &&
          (elem.histogram.name === 'bar')));
    assert.isUndefined(barCell);

    // As users type in regexes, some intermediate forms may be invalid regexes.
    // When the search is an invalid regex, just ignore it.
    await table.viewState.update({searchQuery: '[a-'});

    fooCell = tr.b.findDeepElementMatchingPredicate(
        table, elem => (
          (elem.tagName === 'TR-V-UI-HISTOGRAM-SET-TABLE-CELL') &&
          (elem.histogram.name === 'foo')));
    assert.isDefined(fooCell);

    barCell = tr.b.findDeepElementMatchingPredicate(
        table, elem => (
          (elem.tagName === 'TR-V-UI-HISTOGRAM-SET-TABLE-CELL') &&
          (elem.histogram.name === 'bar')));
    assert.isDefined(barCell);
  });

  test('shortName', async function() {
    // One value has |name|='long name' and |shortName|='short name',
    // another value has |name|='short name' to demonstrate the fundamental
    // ambiguity that arises when Histograms can have multiple different
    // "names".

    const now = new Date().getTime();
    const histograms = new tr.v.HistogramSet();

    const histA = new tr.v.Histogram('long name',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, TEST_BOUNDARIES);
    for (let i = 0; i < 100; ++i) {
      histA.addSample(Math.random() * 1e3);
    }
    histA.shortName = 'short name';
    new tr.v.d.TelemetryInfo({
      label: 'iteration A',
      benchmarkStartMs: now,
    }).addToHistogram(histA);
    histograms.addHistogram(histA);

    const histB = new tr.v.Histogram('short name',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, TEST_BOUNDARIES);
    for (let i = 0; i < 100; ++i) {
      histB.addSample(Math.random() * 1e3);
    }
    new tr.v.d.TelemetryInfo({
      label: 'iteration B',
      benchmarkStartMs: now,
    }).addToHistogram(histB);
    histograms.addHistogram(histB);

    const table = await buildTable(this, histograms);

    // TODO(benjhayden): The shortName version of GROUPINGS.HISTOGRAM_NAME moved
    // to histogram_set_view. Move this test to histogram_set_view_test.
    /*
    assert.isDefined(tr.b.findDeepElementMatchingPredicate(
        table, e => e.textContent === 'short name'));
    assert.isUndefined(tr.b.findDeepElementMatchingPredicate(
        table, e => e.textContent === 'long name'));
    */
  });

  test('emptyAndMissing', async function() {
    const now = new Date().getTime();
    const histograms = new tr.v.HistogramSet();

    const histA = new tr.v.Histogram('histogram A',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, TEST_BOUNDARIES);
    for (let i = 0; i < 100; ++i) {
      histA.addSample(Math.random() * 1e3);
    }
    new tr.v.d.TelemetryInfo({
      label: 'iteration A',
      benchmarkStartMs: now,
    }).addToHistogram(histA);
    histograms.addHistogram(histA);

    const histB = new tr.v.Histogram('histogram B',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, TEST_BOUNDARIES);
    for (let i = 0; i < 100; ++i) {
      histB.addSample(Math.random() * 1e3);
    }
    new tr.v.d.TelemetryInfo({
      label: 'iteration B',
      benchmarkStartMs: now,
    }).addToHistogram(histB);
    histograms.addHistogram(histB);

    const histC = new tr.v.Histogram('histogram A',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, TEST_BOUNDARIES);
    new tr.v.d.TelemetryInfo({
      label: 'iteration B',
      benchmarkStartMs: now,
    }).addToHistogram(histC);
    histograms.addHistogram(histC);

    const table = await buildTable(this, histograms);

    assert.isDefined(tr.b.findDeepElementMatchingPredicate(
        table, e => e.textContent === '(empty)'));
    assert.isDefined(tr.b.findDeepElementMatchingPredicate(
        table, e => e.textContent === '(missing)'));
  });

  test('instantiate_1x1', async function() {
    const histograms = new tr.v.HistogramSet();

    const hist = new tr.v.Histogram('foo',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, TEST_BOUNDARIES);
    for (let i = 0; i < 100; ++i) {
      hist.addSample(Math.random() * 1e3);
    }
    histograms.addHistogram(hist);

    const table = await buildTable(this, histograms);

    const baseTable = getBaseTable(table);
    assert.strictEqual(baseTable.tableRows.length, 1);

    const cell = tr.b.findDeepElementMatchingPredicate(table, elem =>
        elem.tagName === 'TR-V-UI-SCALAR-SPAN');
    cell.click();

    const yAxisText = tr.b.findDeepElementMatchingPredicate(table, e =>
        e.tagName === 'text' && e.textContent === '<0.000 ms');
    assert.isBelow(0, yAxisText.getBBox().width);
  });

  test('merge_unmergeable', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('foo', {telemetry: {storyDisplayName: 'A', label: 'Value'}}),
      newHistogram('foo', {
        boundaries: tr.v.HistogramBinBoundaries.createLinear(0, 1e3, 21),
        telemetry: {storyDisplayName: 'B', label: 'Value'},
      }),
    ]);
    const table = await buildTable(this, histograms);
    assert.strictEqual(table.viewState.tableRowStates.size, 1);
    assert.instanceOf(tr.b.getOnlyElement(getTableCells(table)).histogram,
        tr.v.HistogramSet);
  });

  // TODO(benjhayden): Merge this with the pure instantiation 'merged' test.
  test('instantiate_1x5', async function() {
    const histograms = new tr.v.HistogramSet();

    for (let i = 0; i < 5; ++i) {
      const hist = new tr.v.Histogram('foo',
          tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, TEST_BOUNDARIES);
      for (let i = 0; i < 100; ++i) {
        hist.addSample(Math.random() * 1e3);
      }
      histograms.addHistogram(hist);
      new tr.v.d.TelemetryInfo({
        label: '' + i,
        benchmarkStartMs: new Date().getTime(),
      }).addToHistogram(hist);
    }

    const table = await buildTable(this, histograms);
  });

  // TODO(benjhayden): Merge this with the pure instantiation 'merged' test.
  test('instantiate_2x2', async function() {
    const histograms = new tr.v.HistogramSet([
      newHistogram('foo', {
        samples: range(0, 100).map(i => Math.random() * 1e3),
        telemetry: {
          label: 'iteration A',
          benchmarkStartMs: new Date().getTime(),
        },
      }),
      newHistogram('bar', {
        samples: range(0, 100).map(i => Math.random() * 1e3),
        telemetry: {
          label: 'iteration A',
          benchmarkStartMs: new Date().getTime(),
        },
      }),
      newHistogram('foo', {
        samples: range(0, 100).map(i => Math.random() * 1e3),
        telemetry: {
          label: 'iteration B',
          benchmarkStartMs: new Date().getTime(),
        },
      }),
      newHistogram('bar', {
        samples: range(0, 100).map(i => Math.random() * 1e3),
        telemetry: {
          label: 'iteration B',
          benchmarkStartMs: new Date().getTime(),
        },
      }),
    ]);
    const table = await buildTable(this, histograms);
    const baseTable = getBaseTable(table);

    assert.lengthOf(baseTable.tableColumns, 3);
    assert.strictEqual('Name',
        baseTable.tableColumns[0].title.children[0].textContent);
    assert.strictEqual('iteration A',
        baseTable.tableColumns[1].title.textContent);
    assert.strictEqual('iteration B',
        baseTable.tableColumns[2].title.textContent);

    await table.viewState.update({referenceDisplayLabel: 'iteration A'});
    baseTable.rebuild();
    assert.strictEqual(1, baseTable.selectedTableColumnIndex);
    let cells = getTableCells(table);
    assert.strictEqual(cells[1].referenceHistogram, cells[0].histogram);
    assert.strictEqual(cells[3].referenceHistogram, cells[2].histogram);

    await table.viewState.update({referenceDisplayLabel: 'iteration B'});
    cells = getTableCells(table);
    assert.strictEqual(2, baseTable.selectedTableColumnIndex);
    assert.strictEqual(cells[0].referenceHistogram, cells[1].histogram);
    assert.strictEqual(cells[2].referenceHistogram, cells[3].histogram);

    // Test sorting by the reference column when the displayStatistic is a delta
    // statistic.
    await table.viewState.update({sortColumnIndex: 2});
    let nameCell = getNameCells(table)[0];
    const originalFirstRow = nameCell.row.name;
    // This is either 'foo' or 'bar' depending on Math.random() above.

    await table.viewState.update({
      sortDescending: !table.viewState.sortDescending,
    });
    baseTable.rebuild();
    nameCell = getNameCells(table)[0];
    assert.notEqual(originalFirstRow, nameCell.row.name);
  });

  // TODO(benjhayden): Move this to a pure instantiation test in
  // histogram_set_view_test.html
  test('merged', async function() {
    const histograms = new tr.v.HistogramSet();
    // Add 2^8=256 Histograms, all with the same name, with different
    // TelemetryInfos.
    const benchmarkNames = ['bm A', 'bm B'];
    const storyGroupingKeys0 = ['A', 'B'];
    const storyGroupingKeys1 = ['C', 'D'];
    const storyNames = ['story A', 'story B'];
    const starts = [1439708400000, 1439794800000];
    const labels = ['label A', 'label B'];
    const name = 'name '.repeat(20);

    for (const benchmarkName of benchmarkNames) {
      for (const storyGroupingKey0 of storyGroupingKeys0) {
        for (const storyGroupingKey1 of storyGroupingKeys1) {
          for (const storyName of storyNames) {
            for (const startMs of starts) {
              for (let storysetCounter = 0; storysetCounter < 2;
                  ++storysetCounter) {
                for (const label of labels) {
                  histograms.addHistogram(newHistogram(name, {
                    unit: tr.b.Unit.byName.timeDurationInMs_smallerIsBetter,
                    description: 'The best description.',
                    samples: range(0, 100).map(i => [
                      Math.random() * 1e3, {x: new tr.v.d.Generic(i)}]),
                    telemetry: {
                      storyGroupingKeys: {
                        storyGroupingKey0,
                        storyGroupingKey1,
                      },
                      benchmarkName,
                      storyDisplayName: storyName,
                      benchmarkStartMs: startMs,
                      storysetRepeatCounter: storysetCounter,
                      label,
                    },
                  }));
                }
              }
            }
          }
        }
      }
    }

    const table = await buildTable(this, histograms);
    await table.viewState.update({groupings: [
      tr.v.HistogramSet.GROUPINGS.HISTOGRAM_NAME,
      tr.v.HistogramSet.GROUPINGS.BENCHMARK_NAME,
      new tr.v.HistogramGrouping('storyGroupingKey_storyGroupingKey0',
          tr.v.d.TelemetryInfo.makeStoryGroupingKeyLabelGetter(
              'storyGroupingKey0')),
      new tr.v.HistogramGrouping('storyGroupingKey_storyGroupingKey1',
          tr.v.d.TelemetryInfo.makeStoryGroupingKeyLabelGetter(
              'storyGroupingKey1')),
      tr.v.HistogramSet.GROUPINGS.STORY_NAME,
      tr.v.HistogramSet.GROUPINGS.BENCHMARK_START,
      tr.v.HistogramSet.GROUPINGS.STORYSET_REPEAT,
    ]});
    const baseTable = getBaseTable(table);

    assert.lengthOf(baseTable.tableColumns, 3);
    const nameHeaderCell = baseTable.tableColumns[0].title;
    assert.strictEqual('Name', nameHeaderCell.children[0].textContent);
    assert.strictEqual('label A', baseTable.tableColumns[1].title.textContent);
    assert.strictEqual('label B', baseTable.tableColumns[2].title.textContent);

    const nameCell = tr.b.getOnlyElement(getNameCells(table));
    assert.closeTo(346, nameCell.getBoundingClientRect().width, 1);

    nameHeaderCell.children[1].click();
    // toggleNameColumnWidth_ does not await viewState.update()
    await tr.b.animationFrame();
    assert.isBelow(322, nameCell.getBoundingClientRect().width);

    nameHeaderCell.children[1].click();
    await tr.b.animationFrame();
    assert.closeTo(346, nameCell.getBoundingClientRect().width, 1);

    assert.lengthOf(baseTable.tableRows, 1);
    assert.strictEqual(name, baseTable.tableRows[0].name);
    assert.lengthOf(baseTable.tableRows[0].subRows, 2);

    // assertions only report their arguments, which is not enough information
    // to diagnose problems with nested structures like tableRows -- the path to
    // the particular row is needed. This code would be a bit simpler if each
    // row were given a named variable, but the path to each subRow would still
    // need to be tracked in order to provide for diagnosing.
    const subRowPath = [];
    function getSubRow() {
      let row = baseTable.tableRows[0];
      for (const index of subRowPath) {
        row = row.subRows[index];
      }
      return row;
    }

    for (let i = 0; i < benchmarkNames.length; ++i) {
      subRowPath.push(i);
      assert.lengthOf(getSubRow().subRows, 2, subRowPath);
      assert.strictEqual(benchmarkNames[i], getSubRow().name, subRowPath);

      for (let s = 0; s < storyGroupingKeys0.length; ++s) {
        subRowPath.push(s);
        assert.lengthOf(getSubRow().subRows, 2, subRowPath);
        assert.strictEqual('storyGroupingKey0: ' + storyGroupingKeys0[s],
            getSubRow().name, subRowPath);

        for (let t = 0; t < storyGroupingKeys1.length; ++t) {
          subRowPath.push(t);
          assert.lengthOf(getSubRow().subRows, 2, subRowPath);
          assert.strictEqual('storyGroupingKey1: ' + storyGroupingKeys1[t],
              getSubRow().name, subRowPath);

          for (let j = 0; j < storyNames.length; ++j) {
            subRowPath.push(j);
            assert.lengthOf(getSubRow().subRows, 2, subRowPath);
            assert.strictEqual(storyNames[j], getSubRow().name, subRowPath);

            for (let k = 0; k < starts.length; ++k) {
              subRowPath.push(k);
              assert.lengthOf(getSubRow().subRows, 2, subRowPath);
              assert.strictEqual(tr.b.formatDate(new Date(starts[k])),
                  getSubRow().name, subRowPath);

              for (let l = 0; l < 2; ++l) {
                subRowPath.push(l);
                assert.lengthOf(getSubRow().subRows, 0, subRowPath);
                assert.strictEqual('storyset repeat ' + l, getSubRow().name,
                    subRowPath);
                subRowPath.pop();
              }
              subRowPath.pop();
            }
            subRowPath.pop();
          }
          subRowPath.pop();
        }
        subRowPath.pop();
      }
      subRowPath.pop();
    }
  });
});
</script>
